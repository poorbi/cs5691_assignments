# -*- coding: utf-8 -*-
"""Q1(iii).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1l7XHk0tsZadigsJlg8nhrgOYcNELIZJk
"""

#Importing required modules
import pandas as pd
import numpy as np
import math
import matplotlib.pyplot as plt
import random
import sys

#Extracting data from given csv file
data = pd.read_csv('A2Q1.csv', header=None, index_col=False)
X = np.array(data)

#Function that performs K-means Clustering and returns clusters and their mean after convergence of Lloyd's algorithm
def return_len(K,mX1,mX2,mX3,mX4):
  check = 1

  it = 0
  iter = []
  errorSum = []

  #Iterations for reassignment of means to data points
  while(check):

      check = 0

      for i in range(len(K)):
          z = K[i][50]
          mindist = sys.maxsize

          #Finding minimum distance of every point to the means and assigning it that cluster

          sum1 = 0

          if(len(mX1)!=0 ):
            for q in range(50):
              sum1 = sum1 + (K[i][q]-mX1[q])**2
            if (sum1)**0.5 < mindist:
                mindist = (sum1)**0.5
                z = 1
          
          sum2 = 0

          if(len(mX2)!=0 ):
            for q in range(50):
              sum2 = sum2 + (K[i][q]-mX2[q])**2
            if (sum2)**0.5 < mindist:
                mindist = (sum2)**0.5
                z = 2
          
          sum3 = 0

          if(len(mX3)!=0 ):
            for q in range(50):
              sum3 = sum3 + (K[i][q]-mX3[q])**2
            if (sum3)**0.5 < mindist:
                mindist = (sum3)**0.5
                z = 3

          sum4 = 0
          if(len(mX4)!=0 ):
            for q in range(50):
              sum4 = sum4 + (K[i][q]-mX4[q])**2
            if (sum4)**0.5 < mindist:
                mindist = (sum4)**0.5
                z = 4
              
          if(K[i][50]!=z):
              K[i][50]=z
              check = 1
      
      #Storing all the data points in their respective clusters represented as lists

      X1 =[]
      X2 =[]
      X3 =[]
      X4 =[]

      for i in range(len(K)):
          
          if(K[i][50]==1):
            X11=[]
            for r in range(50):
              X11.append(K[i][r])
            X1.append(X11)

      for i in range(len(K)):
          if(K[i][50]==2):
            X12=[]
            for r in range(50):
              X12.append(K[i][r])
            X2.append(X12)

      for i in range(len(K)):
          if(K[i][50]==3):
            X13=[]
            for r in range(50):
              X13.append(K[i][r])
            X3.append(X13)

      for i in range(len(K)):
          if(K[i][50]==4):
            X14=[]
            for r in range(50):
              X14.append(K[i][r])
            X4.append(X14)

      
      #Recalculating means of all clusters after resassigment step

      mX1 = [float(sum(l))/len(l) for l in zip(*X1)]
      mX2 = [float(sum(l))/len(l) for l in zip(*X2)]
      mX3 = [float(sum(l))/len(l) for l in zip(*X3)]
      mX4 = [float(sum(l))/len(l) for l in zip(*X4)]

      it+=1

      #Finding error sum for every iteration and appending it into a list

      sumE = 0
      for i in range(len(K)):
        if(K[i][50]==1):
          if(len(mX1)!=0):
            sum1 = 0
            for rs in range(50):
              sum1 += ((K[i][rs]-mX1[rs])**2)
            sumE += (sum1)**0.5
        if(K[i][50]==2):
          if(len(mX1)!=0):
            sum2 = 0
            for rs in range(50):
              sum2 += ((K[i][rs]-mX2[rs])**2)
            sumE += (sum2)**0.5
        if(K[i][50]==3):
          if(len(mX1)!=0):
            sum3 = 0
            for rs in range(50):
              sum3 += ((K[i][rs]-mX3[rs])**2)
            sumE += (sum3)**0.5
        if(K[i][50]==4):
          if(len(mX1)!=0):
            sum4 = 0
            for rs in range(50):
              sum4 += ((K[i][rs]-mX4[rs])**2)
            sumE += (sum4)**0.5
      iter.append(it)
      errorSum.append(sumE)
      
  return len(X1),len(X2),len(X3),len(X4),mX1,mX2,mX3,mX4,iter,errorSum

w,h=len(X[0])+1,len(X)

K=[[0 for i in range(w)] for j in range(h)]

for i in range(len(X)):
    for j in range(len(X[0])):
        K[i][j] = X[i][j]

for i in range(len(X)):
    K[i][50] = 0

mX1=[]
mX2=[]
mX3=[]
mX4=[]

#Randomly choosing mean as any data point from dataset

i1 = random.randint(0,len(K)-1)
for i in range(50):
  mX1.append(K[i1][i])
i2 = random.randint(0,len(K)-1)
for i in range(50):
  mX2.append(K[i2][i])
i3 = random.randint(0,len(K)-1)
for i in range(50):
  mX3.append(K[i3][i])
i4 = random.randint(0,len(K)-1)
for i in range(50):
  mX4.append(K[i4][i])

l1,l2,l3,l4,m1,m2,m3,m4,iter,errorSum = return_len(K,mX1,mX2,mX3,mX4)

#Plotting the Error vs Iteration plot
g = plt.figure(1)
plt.xlabel('x-axis')
plt.ylabel('y-axis')
plt.title("Error vs Iteration",color='black')
plt.grid()
plt.plot(iter,errorSum)

plt.show()